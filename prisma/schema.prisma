generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [pgcrypto]
}

// 회원 테이블
model User {
  idx               Int         @id @default(autoincrement())
  user_id           String      @unique
  password          String?
  nickname          String      @unique
  profile_img        String      @default("")
  oauth_provider    String?
  oauth_provider_id String?
  created_at         DateTime    @default(dbgenerated("timezone('Asia/Seoul', now())"))
  updated_at         DateTime    @updatedAt()
  
  userDetail      UserDetail?
  channel         Channel?
  ivs             IVSChannel?
  broadcastSetting BroadCastSetting?
  UserTerms       UserTerms[]
  coin            Coin?
  
  streams        Stream? @relation("StreamData")
  // Gift relations
  sentGifts      Gift[] @relation("GiftSender")
  receivedGifts  Gift[] @relation("GiftRecipient")

  // Posts relations
  sentPosts      Posts[] @relation("SentPosts")
  receivedPosts  Posts[] @relation("ReceivedPosts")
  
  // Fan relations
  fans           Fan[] @relation("UserFans")
  following      Fan[] @relation("UserFollowing")
  
  // Fan Rank Tier relation
  fanLevel       FanLevel[] @relation("CreatorRankTiers")
  
  // Block relations
  blockedUsers   PostBlockedUsers[] @relation("PostBlockingUser")
  blockedBy      PostBlockedUsers[] @relation("PostBlockedUser")
  
  // Stream viewer relation
  viewingSessions StreamViewer[] @relation("StreamViewers")
}

// 유저 상세 정보 (개인정보는 암호화 AES암호화 + base64 인코딩 하여 저장)
model UserDetail {
  user_idx        Int      @id
  name            String   
  sex             String   
  resident_number String   // 암호화 필요
  phone           String   // 암호화 필요
  email           String   @unique // 암호화 필요
  address         String   // 암호화 필요
  created_at       DateTime @default(dbgenerated("timezone('Asia/Seoul', now())"))
  User            User     @relation(fields: [user_idx], references: [idx], onDelete: Cascade)  // 반드시 1:1 관계를 유지하도록 설정
}

// 이용약관
model Terms {
  id     Int         @id @default(autoincrement())
  version       Float
  content       String
  effectiveDate DateTime
  created_at     DateTime    @default(dbgenerated("timezone('Asia/Seoul', now())"))
  UserTerms     UserTerms[]
}

// 이용약관 동의 여부
model UserTerms {
  id Int      @id @default(autoincrement())
  agreedAt       DateTime
  createdAt      DateTime @default(dbgenerated("timezone('Asia/Seoul', now())"))

  // Relations
  user_idx       Int
  terms_id      Int
  user  User  @relation(fields: [user_idx], references: [idx], onDelete: Cascade)
  terms Terms @relation(fields: [terms_id], references: [id], onDelete: Cascade)

  // Constraints
  @@unique([user_idx, terms_id]) // 한 사용자당 한 약관 버전에 대해 한 번만 동의 가능
}

// 채널 테이블
model Channel {
  user_idx          Int      @id 
  title             String   @default("")
  bookmark          Int      @default(0)
  like              Int      @default(0)
  watch             Int      @default(0)
  month_time        Int      @default(0)
  total_time        Int      @default(0)
  first_start_time  DateTime?
  createdAt         DateTime @default(dbgenerated("timezone('Asia/Seoul', now())"))

  // Relations
  User User @relation(fields: [user_idx], references: [idx], onDelete: Cascade)
}

model BroadCastSetting {
  user_idx          Int      @id
  title             String
  is_adult          Boolean  @default(false)
  is_pw             Boolean  @default(false)
  //팬 등급 제한 설정
  is_fan            Boolean  @default(false)
  fan_level         Int      @default(1)
  password          String?  // 비밀번호 (암호화 필요)
  createdAt         DateTime @default(dbgenerated("timezone('Asia/Seoul', now())"))
  updatedAt         DateTime @updatedAt()

  // Relations
  User User @relation(fields: [user_idx], references: [idx], onDelete: Cascade)
}

// AWS IVS 채널 정보
model IVSChannel {
  user_idx                Int        @id
  arn                     String?    @unique
  ingest_endpoint         String?    @unique
  playback_url            String?    @unique
  stream_key              String?    @unique
  stream_key_arn          String?    @unique
  recording_arn           String?
  restriction_policy_arn  String?
  name                    String?
  createdAt               DateTime   @default(now())

  // relations
  User User @relation(fields: [user_idx], references: [idx], onDelete: Cascade)
}
// Stream 정보
// 이 정보들은 아마 서비스할때에는 redis에 복사본을 들고있다가 
// 일정 주기별로 업데이트를 하는 방식으로 사용될듯(?)
model Stream {
  id              Int      @id @default(autoincrement())
  request_id      String
  stream_id       String   @unique
  title           String
  start_time      String

  play_cnt        Int      @default(0)
  like_cnt        Int      @default(0)
  thumbnail       String   @default("")
  is_adult        Boolean
  is_pw           Boolean
  is_fan          Boolean 
  password        String?  // 비밀번호 (암호화 필요)
  fan_level       Int?     // 팬 등급 제한 설정
 

  // Relations
  user_idx        Int      @unique
  user            User     @relation("StreamData", fields: [user_idx], references: [idx], onDelete: Cascade)
  
  // Stream viewers relation
  viewers         StreamViewer[]
}

// 시청자 정보 테이블 - 스트림 시청 정보 관리
model StreamViewer {
  id              Int      @id @default(autoincrement())
  // Relations
  stream_id       Int      // 시청 중인 스트림 ID
  viewer_idx      Int      // 시청자 ID
  stream          Stream   @relation(fields: [stream_id], references: [id], onDelete: Cascade)
  viewer          User     @relation("StreamViewers", fields: [viewer_idx], references: [idx], onDelete: Cascade)
  @@unique([stream_id, viewer_idx]) // 한 사용자는 스트림당 하나의 시청 세션만 가질 수 있음
}

// 쪽지 테이블 (유저간 메시지)
model Posts {
  id             Int      @id @default(autoincrement())
  content         String   // 쪽지 내용
  is_read         Boolean  @default(false) // 읽음 상태
  sent_at         DateTime @default(dbgenerated("timezone('Asia/Seoul', now())"))
  read_at         DateTime? // 읽은 시간

  // Relations
  sender_idx      Int      // 보낸 사용자
  recipient_idx   Int      // 받는 사용자
  sender     User   @relation("SentPosts", fields: [sender_idx], references: [idx], onDelete: Cascade)
  recipient  User   @relation("ReceivedPosts", fields: [recipient_idx], references: [idx], onDelete: Cascade)
}

// 코인 정보 테이블 - 사용자별 코인 잔액 관리
model Coin {
  user_idx        Int      @id
  balance         Int      @default(0)
  total_received  Int      @default(0)
  total_spent     Int      @default(0)
  total_charged   Int      @default(0)
  last_updated    DateTime @updatedAt
  created_at      DateTime @default(dbgenerated("timezone('Asia/Seoul', now())"))

  // Relations
  user            User     @relation(fields: [user_idx], references: [idx], onDelete: Cascade)
}

// 선물(후원) 기록 테이블 - 사용자 간 코인 선물 기록
model Gift {
  id              Int      @id @default(autoincrement())
  sender_idx      Int      // 선물을 보낸 사용자
  recipient_idx   Int      // 선물을 받은 사용자
  amount          Int      // 선물한 코인 양
  message         String?  // 선물과 함께 보낸 메시지
  stream_id       Int?     // 연결된 스트림 (선물이 특정 스트림에서 이루어진 경우)
  created_at      DateTime @default(dbgenerated("timezone('Asia/Seoul', now())"))
  
  // Relations
  sender          User     @relation("GiftSender", fields: [sender_idx], references: [idx])
  recipient       User     @relation("GiftRecipient", fields: [recipient_idx], references: [idx])
}


// 팬 관계 테이블 - 사용자간 팬 관계 관리
model Fan {
  id             Int      @id @default(autoincrement())

  total_donation     Int      @default(0) // 팬이 보낸 총 선물 수
  created_at      DateTime @default(dbgenerated("timezone('Asia/Seoul', now())"))
  updated_at      DateTime @updatedAt
  
  // Relations
  creator_id     Int      // 크리에이터(팔로우 당하는 사람) 인덱스
  creator         User     @relation("UserFans", fields: [creator_id], references: [idx], onDelete: Cascade)

  fan_idx         Int      // 팬(팔로우 하는 사람) 인덱스
  fan             User     @relation("UserFollowing", fields: [fan_idx], references: [idx], onDelete: Cascade)

  // Ensure a user can only follow another user once
  @@unique([creator_id, fan_idx])
}

// 팬 등급 시스템 - 각 크리에이터별 팬 등급 정의
model FanLevel {
  id               Int      @id @default(autoincrement())
  
  name             String   // 등급 이름 (예: "브론즈", "실버", "골드")
  min_donation     Int      // 해당 등급에 도달하기 위한 최소 후원 금액
  created_at       DateTime @default(dbgenerated("timezone('Asia/Seoul', now())"))
  updated_at       DateTime @updatedAt
  
  // Relations
  user_idx      Int      // 크리에이터(등급 소유자) 인덱스
  user         User     @relation("CreatorRankTiers", fields: [user_idx], references: [idx], onDelete: Cascade)
  
  // 한 크리에이터는 같은 이름의 등급을 중복해서 가질 수 없음
  @@unique([user_idx, name])
}

// 유저 차단 테이블 - 메시지 차단 관리
model PostBlockedUsers {
  id              Int      @id @default(autoincrement())
  created_at      DateTime @default(dbgenerated("timezone('Asia/Seoul', now())"))
  
  // Relations
  blocker_idx     Int      // 차단한 사용자
  blocked_idx     Int      // 차단된 사용자
  blocker         User     @relation("PostBlockingUser", fields: [blocker_idx], references: [idx], onDelete: Cascade)
  blocked         User     @relation("PostBlockedUser", fields: [blocked_idx], references: [idx], onDelete: Cascade)
  
  // Ensure a user can only block another user once
  @@unique([blocker_idx, blocked_idx])
}